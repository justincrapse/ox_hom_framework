<?xml version="1.0" encoding="UTF-8"?>
<shelfDocument>
  <!-- This file contains definitions of shelves, toolbars, and tools.
 It should not be hand-edited when it is being used by the application.
 Note, that two definitions of the same element are not allowed in
 a single file. -->

  <tool name="scatter_group0" label="Scatter Group" icon="sunflower_icon.png">
    <script scriptType="python"><![CDATA[# ui: confirm selected
# create geo node
# object merge node for each selected
# create names for each based on node selected
# plug into a basic/default scatter atr from pieces
# add in a transform for good measure (after merge)

# R2:
# promote weight attributes
# promote other attrs
import random

import hou
from hou_helper.base_objects import hh_node
from hou_helper import nodes


obj_node = hou.node('/obj')
hh_obj_node = hh_node.HHNode(node=obj_node)
print(f'obj node: {obj_node}')
selected_nodes = hou.selectedNodes()
node_names_string = '\n '.join([i.name() for i in selected_nodes])
if not selected_nodes:
    hou.ui.displayMessage(text='Must select nodes before generating scatter group instancing')
response = hou.ui.displayConfirmation(f"Nodes selected for scattering: \n{node_names_string}", title="Verify Selected Nodes")
if not response:
    exit()

parent_node = selected_nodes[0].parent()
print(f'parent: {parent_node.name()}')
scatter_group_node_name = f'scatter_group{parent_node.name()}'
scatter_group_geo_node = nodes.obj_nodes.GeoNode(hh_parent=hh_obj_node, node_name=scatter_group_node_name)
scatter_group_geo_node.parm_rs_objprop_inst_packedpriminstancing = True
merge_node = nodes.geo_nodes.MergeNode(hh_parent=scatter_group_geo_node)
for index, node in enumerate(selected_nodes):
    node_path = node.path()
    node_name = node.name()
    piece_attribute = 'name'
    merge_node_name = f'merge_{node_name}'
    color_node_name = f'color_{node_name}'
    name_node_name = f'name_{node_name}'
    obj_merge_node = nodes.geo_nodes.ObjectMergeNode(hh_parent=scatter_group_geo_node, node_name=merge_node_name)
    obj_merge_node.parm_objpath1 = node_path
    name_node = nodes.geo_nodes.NameNode(hh_parent=scatter_group_geo_node)
    name_node.parm_name1 = node_name
    name_node.connect_from(hh_node=obj_merge_node)
    color_node = nodes.geo_nodes.ColorNode(hh_parent=scatter_group_geo_node, node_name=color_node_name)
    color_node.connect_from(hh_node=name_node)
    color_node.parm_colorb = random.random()
    color_node.parm_colorg = random.random()
    color_node.parm_colorr = random.random()
    merge_node.connect_from(hh_node=color_node, input_index=index)

xform_node = nodes.geo_nodes.TransformNode(hh_parent=scatter_group_geo_node)
xform_node.connect_from(hh_node=merge_node)
copy2points_node = nodes.geo_nodes.CopytopointsNode(hh_parent=scatter_group_geo_node)
copy2points_node.parm_useidattrib = True
copy2points_node.parm_idattrib_menu = piece_attribute
copy2points_node.connect_from(hh_node=xform_node)

grid_node = nodes.geo_nodes.GridNode(hh_parent=scatter_group_geo_node)
scatter_node = nodes.geo_nodes.ScatterNode(hh_parent=scatter_group_geo_node)
scatter_node.connect_from(hh_node=grid_node)
scatter_node.parm_npts = 100

attrib_from_pieces_node = nodes.geo_nodes.AttribfrompiecesNode(hh_parent=scatter_group_geo_node)
attrib_from_pieces_node.parm_pieceattrib_menu = piece_attribute
attrib_from_pieces_node.connect_from(hh_node=scatter_node)
attrib_from_pieces_node.connect_from(hh_node=xform_node, input_index=1)
copy2points_node.connect_from(hh_node=attrib_from_pieces_node, input_index=1)
copy2points_node.parm_pack = True
copy2points_node.node.setDisplayFlag(on=True)
copy2points_node.node.setRenderFlag(on=True)
]]></script>
  </tool>

  <tool name="node_class_generator" label="Node Class Generator" icon="cat_icon">
    <script scriptType="python"><![CDATA["""
This beautiful bit of code takes selected nodes and generates OX node classes for them. Also registers them in the framework for easy
importing and shorter type hinting. 
"""

import logging

import hou
from ox.base_objects.ox_node import OXNode
from ox.utils.gen_classes import gen_node_classes
from ox.utils import ui

ox_logger = logging.getLogger("ox_logger")

node_to_folder_map = {
    "obj": "obj_nodes",
    "geo": "geo_nodes",
    "matnet": "matnet_nodes",
    "redshift_vopnet": "redshift_nodes",
    "cop2net": "cop_nodes",
}

obj_node = hou.node("/obj")
hh_obj_node = OXNode(node=obj_node)
selected_nodes = hou.selectedNodes()


for node in selected_nodes:
    parent_type = node.parent().type().name()
    node_type = node.type().name()
    if node_type == "labs::hf_combine_masks":
        ui.display_confirmation(
            f'This node type "{node_type}" should have parm "folder0" parm to at least 1. cancel to exit, otherwise accept node \
        as it is'
        )
        node.parm("folder0").set(1)
    try:
        sub_dir = node_to_folder_map[parent_type]
    except KeyError:
        raise KeyError(
            f"{parent_type} Parent type not found as a key in the node_to_folder_map. You will need to add that folder, then update the map"
        )
    ox_logger.info(f"Generating node class for node type: {node_type}. sub_dir: {sub_dir}")
    gen_node_classes.generate_node_class(node=node, sub_dir=sub_dir)
]]></script>
  </tool>

  <toolshelf name="ox_admin" label="OX:Admin">
    <memberTool name="node_class_generator"/>
    <memberTool name="regenerate_node_classes"/>
    <memberTool name="examples"/>
    <memberTool name="sandbox"/>
  </toolshelf>

  <tool name="regenerate_node_classes" label="Regenerate Node Classes" icon="cat_blue_icon">
    <script scriptType="python"><![CDATA[import inspect
import logging
from collections import defaultdict

import hou
from ox.base_objects.ox_node import OXNode
from ox.utils.gen_classes import gen_node_classes
from ox import nodes
from ox.utils import ui

ox_logger = logging.getLogger("ox_logger")

obj_node: hou.Node = hou.node("/obj")
ox_obj_node = OXNode(node=obj_node)

node_folder_list = ["obj_nodes", "geo_nodes", "matnet_nodes", "redshift_nodes", "cop_nodes"]

node_cat_list = [i for i in dir(nodes) if not i.startswith("__")]


created_node_dict = defaultdict(list)

ui.display_confirmation(
    message="This will regenerate all existing OX Nodes. Are you sure you want to do this? Press cancel to exit code.", require_confirmation=True
)


######################################################################################################################################################
# OBJ Nodes:
node_dir = "obj_nodes"
source_node: hou.Node = obj_node
node_cat = nodes.obj_nodes

node_name_list = [i for i in dir(node_cat) if not i.startswith("__")]
node_class_list = [getattr(node_cat, i) for i in node_name_list if inspect.isclass(getattr(node_cat, i))]
for node in node_class_list:
    ox_logger.info(f"Node type: {node.node_type}")
    new_node = source_node.createNode(node.node_type)
    gen_node_classes.generate_node_class(node=new_node, sub_dir=node_dir)
    created_node_dict[node_dir].append(node.node_type)


######################################################################################################################################################
# GEO Nodes:
node_dir = "geo_nodes"
source_node = obj_node.createNode("geo")
node_cat = nodes.geo_nodes

node_name_list = [i for i in dir(node_cat) if not i.startswith("__")]
node_class_list = [getattr(node_cat, i) for i in node_name_list if inspect.isclass(getattr(node_cat, i))]
for node in node_class_list:
    ox_logger.info(f"Node type: {node.node_type}")
    new_node = source_node.createNode(node.node_type)

    # handle dynamic parms:
    if node.node_type == "labs::hf_combine_masks":
        new_node.parm("folder0").set(10)

    ox_logger.info(new_node.name())
    gen_node_classes.generate_node_class(node=new_node, sub_dir=node_dir)
    created_node_dict[node_dir].append(node.node_type)


######################################################################################################################################################
# Matnet Nodes:
node_dir = "matnet_nodes"
source_node = obj_node.createNode("matnet")
node_cat = nodes.matnet_nodes

node_name_list = [i for i in dir(node_cat) if not i.startswith("__")]
node_class_list = [getattr(node_cat, i) for i in node_name_list if inspect.isclass(getattr(node_cat, i))]
extra_node = source_node.createNode("mtlxstandard_surface")
for node in node_class_list:
    ox_logger.info(f"Node type: {node.node_type}")
    new_node = source_node.createNode(node.node_type)

    if node.node_type == "collect":
        new_node.setInput(input_index=0, item_to_become_input=extra_node, output_index=0)
        
    ox_logger.info(new_node.name())
    gen_node_classes.generate_node_class(node=new_node, sub_dir=node_dir)
    created_node_dict[node_dir].append(node.node_type)


######################################################################################################################################################
# Redshift Nodes:
node_dir = "redshift_nodes"
matnet_node = obj_node.createNode("matnet")
source_node: hou.Node = matnet_node.createNode("redshift_vopnet")
source_node.deleteItems(source_node.allItems())
node_cat = nodes.redshift_nodes

node_name_list = [i for i in dir(node_cat) if not i.startswith("__")]
node_class_list = [getattr(node_cat, i) for i in node_name_list if inspect.isclass(getattr(node_cat, i))]
for node in node_class_list:
    ox_logger.info(f"Node type: {node.node_type}")
    new_node = source_node.createNode(node.node_type)
    ox_logger.info(new_node.name())
    gen_node_classes.generate_node_class(node=new_node, sub_dir=node_dir)
    created_node_dict[node_dir].append(node.node_type)


######################################################################################################################################################
# Cop Nodes:
node_dir = "cop_nodes"
source_node: hou.Node = obj_node.createNode("cop2net")
node_cat = nodes.cop_nodes

node_name_list = [i for i in dir(node_cat) if not i.startswith("__")]
node_class_list = [getattr(node_cat, i) for i in node_name_list if inspect.isclass(getattr(node_cat, i))]
for node in node_class_list:
    ox_logger.info(f"Node type: {node.node_type}")
    new_node = source_node.createNode(node.node_type)
    ox_logger.info(new_node.name())
    gen_node_classes.generate_node_class(node=new_node, sub_dir=node_dir)
    created_node_dict[node_dir].append(node.node_type)

for key, value in created_node_dict.items():
    ox_logger.info(f"{key}: {len(value)}")
]]></script>
  </tool>

  <tool name="examples" label="Examples" icon="cat_rainbow">
    <script scriptType="python"><![CDATA[# autocomplete nodes, parm, menu
import logging
import os

import hou

from ox import nodes
from ox.base_objects.ox_node import OXNode
from ox.constants.ox_conf import sesh_vars
from ox.utils import session_utils, file_utils

ox_logger = logging.getLogger("ox_logger")


# obj_node = hou.node("/obj")
# geo_node = obj_node.createNode("geo")
# sphere_node: hou.Node = geo_node.createNode("sphere")
# sphere_node.parm("scale").set(0.5)
# freq_parm: hou.Parm = sphere_node.parm("freq")
# freq_parm.set(1)
# type_parm: hou.Parm = sphere_node.parm("type")
# menu_lookup = dict(zip(type_parm.menuLabels(), type_parm.menuItems()))
# type_parm.set(menu_lookup["Polygon"])

# new_parm_template = hou.ButtonParmTemplate(
#     name="my_button", label="My Button", script_callback="print('Test Button 1')", script_callback_language=hou.scriptLanguage.Python
# )
# parm_template_group: hou.ParmTemplateGroup = sphere_node.parmTemplateGroup()
# freq_pt = freq_parm.parmTemplate()
# parm_template_group.insertAfter(freq_pt, new_parm_template)
# sphere_node.setParmTemplateGroup(parm_template_group=parm_template_group)


obj_node = hou.node("/obj")
ox_obj_node = OXNode(obj_node)
ox_geo_node = nodes.obj_nodes.GeoNode(ox_parent=ox_obj_node)
ox_sphere_node = nodes.geo_nodes.SphereNode(ox_parent=ox_geo_node)
ox_sphere_node.parm_type.menu_polygon
ox_geo_node.add_parm_template()
ox_sphere_node.parm_scale = 0.5
ox_sphere_node.parm_freq = 1

session_utils.set_session_variable(var_name=sesh_vars.LOAD_USER_PRESETS, value=True)
load_user_presets = session_utils.get_session_variable(sesh_vars.LOAD_USER_PRESETS)
if load_user_presets:
    ox_logger.debug(f"loading user preset: {ox_sphere_node.name}")
    ox_sphere_node.load_preset()

button_pt = ox_sphere_node.create_button_parm_template(name="my_button", label="My Button", script_callback="print('Test Button 2')")
ox_sphere_node.add_parm_template(parm_template=button_pt, insert_after_parm=ox_sphere_node.parm_freq.parm)

# folder_path = os.getenv("HIP")
# contents = file_utils.get_dir_contents(folder_path=folder_path)
# print(contents)
]]></script>
  </tool>

  <tool name="sandbox" label="SandBox" icon="pearl_icon">
    <script scriptType="python"><![CDATA[import hou
from ox import OXNode
from ox import nodes
from ox.helpers import ox_helper

root_node = hou.node(".")
print(f"root node: {root_node.name()}")
root_ox_node = OXNode(node=root_node)
print(root_ox_node.get_child_nodes())
exit()


obj_node = hou.node("/obj")
obj_ox_node = OXNode(node=obj_node)

geo_ox_node = nodes.obj_nodes.GeoNode(ox_parent=obj_ox_node, node_name="my_geo")
cube_ox_node = nodes.geo_nodes.BoxNode(ox_parent=geo_ox_node, node_name="my_cube")
cube_ox_node.parm_scale = 2

cube_trans_ox_node = nodes.geo_nodes.TransformNode(ox_parent=geo_ox_node, node_name="cube_trans")
cube_trans_ox_node.connect_from(cube_ox_node)

cube_normal_ox_node = nodes.geo_nodes.NormalNode(ox_parent=geo_ox_node, node_name="cube_norm")
cube_normal_ox_node.connect_from(cube_trans_ox_node)

cube_uv_ox_node = nodes.geo_nodes.UvtextureNode(ox_parent=geo_ox_node, node_name="cube_uv")
cube_uv_ox_node.connect_from(cube_normal_ox_node)
cube_uv_ox_node.parm_type.menu_face
cube_uv_ox_node.parm_sv = cube_uv_ox_node.parm_su.parm
cube_uv_ox_node.parm_sw = cube_uv_ox_node.parm_su.parm

cube_match_size_ox_node = nodes.geo_nodes.MatchsizeNode(ox_parent=geo_ox_node, node_name="cube_match_size")
cube_match_size_ox_node.connect_from(cube_uv_ox_node)
cube_match_size_ox_node.parm_justify_y.menu_min

sphere_ox_node = nodes.geo_nodes.SphereNode(ox_parent=geo_ox_node, node_name="my_sphere")
sphere_trans_ox_node = nodes.geo_nodes.TransformNode(ox_parent=geo_ox_node, node_name="sphere_trans")
sphere_trans_ox_node.connect_from(sphere_ox_node)

sphere_normal_ox_node = nodes.geo_nodes.NormalNode(ox_parent=geo_ox_node, node_name="sphere_norm")
sphere_normal_ox_node.connect_from(sphere_trans_ox_node)

sphere_uv_ox_node = nodes.geo_nodes.UvtextureNode(ox_parent=geo_ox_node, node_name="sphere_uv")
sphere_uv_ox_node.connect_from(sphere_normal_ox_node)
sphere_uv_ox_node.parm_type.menu_face
sphere_uv_ox_node.parm_sv = sphere_uv_ox_node.parm_su.parm
sphere_uv_ox_node.parm_sw = sphere_uv_ox_node.parm_su.parm

sphere_match_size_ox_node = nodes.geo_nodes.MatchsizeNode(ox_parent=geo_ox_node, node_name="sphere_match_size")
sphere_match_size_ox_node.connect_from(sphere_uv_ox_node)
sphere_match_size_ox_node.connect_from(
    ox_node=cube_match_size_ox_node, input_label=sphere_match_size_ox_node.input_geometry_whose_bounding_box_is_to_be_matched
)
sphere_match_size_ox_node.parm_justify_y.menu_min
sphere_match_size_ox_node.parm_goal_y.menu_max

merge_ox_node = nodes.geo_nodes.MergeNode(ox_parent=geo_ox_node)
merge_ox_node.connect_from(cube_match_size_ox_node)
merge_ox_node.connect_from(sphere_match_size_ox_node, input_index=1)
merge_ox_node.set_display_and_render_flags()

ox_helper.reference_node(source_node=sphere_trans_ox_node.node, destination_node=cube_trans_ox_node.node)

geo_ox_node.layout_children()
]]></script>
  </tool>
</shelfDocument>
